---
title: 常用标准库使用
author: MagicGopher
keywords: go, golang, io, fmt, net/http, time, math、bufio
description: 介绍 Go 语言的常用的标准库，包括 os、io、bufio、fmt、net/http、time、math 等。
editLink: false
---

# 常用的标准库

## fmt 包

### 简介

Go 语言的 fmt 包是标准库中最常用的包之一，fmt 是 "format" 的缩写，主要用于格式化输入输出。它提供了丰富的函数，用于打印数据到标准输出、从标准输入读取数据，以及格式化字符串等操作。

fmt 包文档官方地址：[https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)

以下是 fmt 包中主要函数的分类和作用说明：

### 打印函数

这些函数用于将数据格式化并输出到标准输出（os.Stdout），通常用于调试或显示信息。

- `func Print(a ...any) (n int, err error)`
  - 作用：将参数按默认格式打印，参数之间以空格分隔，不添加换行符。
  - 示例：

```go
fmt.Print("Hello", "World") // 输出: Hello World
```

- `func Println(a ...any) (n int, err error)`
  - 作用：类似 Print，但在末尾自动添加换行符。
  - 示例：

```go
fmt.Println("Hello", "World") // 输出: Hello World\n
```

- `func Printf(format string, a ...any) (n int, err error)`
  - 作用：按照指定格式字符串打印参数，支持占位符（如 %d, %s）。
  - 示例：

```go
fmt.Printf("Name: %s, Age: %d\n", "Alice", 25) // 输出: Name: Alice, Age: 25
```

### 格式化字符串函数

这些函数将格式化后的字符串返回，而不是直接打印，适合需要进一步处理字符串的场景。

- `func Sprint(a ...interface{}) string`
  - 作用：将参数按默认格式拼接成字符串返回，参数间用空格分隔。
  - 示例：

```go
s := fmt.Sprint("Hello", "World") // 返回: "Hello World"
```

- `func Sprintln(a ...interface{}) string`
  - 作用：类似 Sprint，但在末尾添加换行符。
  - 示例：

```go
s := fmt.Sprintln("Hello", "World") // 返回: "Hello World\n"
```

- `fmt.Sprintf(format string, a ...interface{}) string`
  - 作用：按照指定格式字符串格式化参数并返回结果。
  - 示例：

```go
s := fmt.Sprintf("Name: %s, Age: %d", "Alice", 25) // 返回: "Name: Alice, Age: 25"
```

### 输入函数

这些函数用于从标准输入（os.Stdin）读取数据，常用于交互式程序。

- `func Scan(a ...interface{}) (n int, err error)`
  - 作用：从标准输入读取数据，按空格或换行符分隔，赋值给传入的变量指针。
  - 示例：

```go
var name string
var age int
fmt.Println("请输出姓名和年龄，例子： Alice 25")
fmt.Scan(&name, &age) // 输入: Alice 25
fmt.Println("Name:", name) // 输出: Name: Alice
fmt.Println("Age:", age) // 输出: Age: 25
```

- `func Scanln(a ...interface{}) (n int, err error)`
  - 作用：类似 Scan，但要求输入以换行符结束，且只读取一行。
  - 示例：

```go
var name string
var age int
fmt.Println("请输出姓名和年龄，例子：Alice 25\n")
fmt.Scanln(&name, &age) // 输入: Alice 25\n
fmt.Println("Name:", name) // 输出: Name: Alice
fmt.Println("Age:", age) // 输出: Age: 25
```

- `func Scanf(format string, a ...interface{}) (n int, err error)`
  - 作用：按照指定格式从标准输入读取数据，赋值给变量指针，支持占位符（如 %s, %d）。
  - 示例：

```go
var name string
var age int
fmt.Println("请输出姓名和年龄，例子：Name: Alice, Age: 25")
fmt.Scanf("Name: %s, Age: %d", &name, &age) // 输入: Name: Alice, Age: 25
fmt.Println("Name:", name) // 输出: Name: Alice
fmt.Println("Age:", age) // 输出: Age: 25
```

### 输出到指定 Writer 的函数

这些函数将格式化结果写入指定的 io.Writer（如文件、网络连接等），而不是标准输出。

- `func Fprint(w io.Writer, a ...interface{}) (n int, err error)`
  - 作用：将参数按默认格式打印到指定 Writer 中，参数之间以空格分隔，不添加换行符。
  - 示例：

```go
fmt.Fprint(os.Stdout, "Hello", "World") // 输出到标准输出: Hello World
```

- `func Fprintln(w io.Writer, a ...interface{}) (n int, err error)`
  - 作用：类似 Fprint，但在末尾自动添加换行符。
  - 示例：

```go
fmt.Fprintln(os.Stdout, "Hello", "World") // 输出到标准输出: Hello World\n
```

- `func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)`
  - 作用：按照指定格式将参数打印到指定 Writer 中，支持占位符（如 %d, %s）。
  - 示例：

```go
fmt.Fprintf(os.Stdout, "Name: %s, Age: %d\n", "Alice", 25) // 输出到标准输出: Name: Alice, Age: 25
```

### 错误格式化函数

这些函数专门用于创建错误类型（error）。

- `func Errorf(format string, a ...interface{}) error`
  - 作用：按照指定格式创建错误对象，支持占位符（如 %s, %d）。
  - 示例：

```go
err := fmt.Errorf("用户 %s 不存在", "Alice") // 返回 error: 用户 Alice 不存在
```

### 其他函数

这些函数不常用，但在特定场景下有用途。

- `fmt.Fscan(r io.Reader, a ...interface{}) (n int, err error)`
  - 作用：从指定 io.Reader 中读取数据，按空格或换行符分隔，赋值给传入的变量指针，类似 Scan。


- `fmt.Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)`
  - 作用：按照指定格式从指定 io.Reader 中读取数据，赋值给变量指针，类似 Scanf。


- `fmt.Fscanln(r io.Reader, a ...interface{}) (n int, err error)`
  - 作用：从指定 io.Reader 中读取数据，按换行符分隔，赋值给传入的变量指针，类似 Scanln。


- `fmt.Sscan(str string, a ...interface{}) (n int, err error)`
  - 作用：从指定字符串中读取数据，按空格或换行符分隔，赋值给传入的变量指针，类似 Sscan。


- `fmt.Sscanf(str string, format string, a ...interface{}) (n int, err error)`
  - 作用：按照指定格式从指定字符串中读取数据，赋值给变量指针，类似 Sscanf。

- `fmt.Sscanln(str string, a ...interface{}) (n int, err error)`
  - 作用：从指定字符串中读取数据，按换行符分隔，赋值给传入的变量指针，类似 Sscanln。

### 总结

- 打印类（Print*）：直接输出到标准输出。
- 字符串类（Sprint*）：返回格式化字符串。
- 输入类（Scan*）：从标准输入读取数据。
- Writer 类（Fprint*）：输出到指定 io.Writer。
- 错误类（Errorf）：创建 error。
- 其他类（Fscan*, Sscan*）：从特定来源读取数据。

fmt 包功能强大且简单易用，是 Go 开发中调试和交互的基础工具。如果需要更复杂的输入输出操作，可以结合 bufio 或 io 包使用。

## io 包

### 简介

Go 语言的 io 包是标准库中用于处理输入输出操作的核心包。它提供了一系列接口和函数，用于抽象和管理数据的读取（Reader）、写入（Writer）以及其他 I/O 操作。io 包的设计高度模块化，强调接口的使用，适合与文件、网络、缓冲区等各种 I/O 场景结合。

io 包文档官方地址：[https://pkg.go.dev/io](https://pkg.go.dev/io)

以下是 io 包中主要函数及其作用的详细说明：

### 数据复制与传输函数

这些函数用于在 Reader 和 Writer 之间高效传输数据。

- `func Copy(dst Writer, src Reader) (written int64, err error)`
  - 作用：从 src（io.Reader）读取数据并写入 dst（io.Writer），直到读取完毕或出现error。
  - 用途：常用于文件复制、网络数据传输等。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

func main() {
	// Copy函数用于将数据从一个 io.Reader 复制到 io.Writer，直到源数据耗尽或者发生错误，它返回复制的字节数和可能遇到的错误。
	// 创建一个字符串作为输入源
	src := strings.NewReader("Hello, World!")
	// 创建一个缓冲区作为输出目标
	dst := new(bytes.Buffer)
	// 使用 io.Copy 函数将数据从 src 复制到 dst
	n, err := io.Copy(dst, src)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Copied %d bytes:%s\n", n, dst.String())
}
```

- `func CopyN(dst Writer, src Reader, n int64) (written int64, err error)`
  - 作用：从 src（io.Reader）读取数据并写入 dst（io.Writer），直到读取 n 个字节或出现 error。
  - 用途：常用于文件复制、网络数据传输等。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

func main() {
	// CopyN：与 Copy类似，但它只复制指定数量的字节（n）。如果源数据不足 n 个字节，会返回 io.EOF
	src := strings.NewReader("Hello, World!")
	dst := new(bytes.Buffer)
	// 只复制前 5 个字节（包括5）
	n, err := io.CopyN(dst, src, 5)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Copied %d bytes:%s\n", n, dst.String())
}
```

- `func CopyBuffer(dst Writer, src Reader, buffer []byte) (written int64, err error)`
  - 作用：从 src（io.Reader）读取数据并写入 dst（io.Writer），直到读取完毕或出现 error。
  - 用途：常用于文件复制、网络数据传输等。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

func main() {
	// CopyBuffer：是 io.Copy 的变种，允许用户指定一个缓冲区来减少底层系统调用的开销，如果缓冲区为 nil，则会自动分配一个 32KB 大小的缓冲区。
	src := strings.NewReader("Hello, World!")
	dst := new(bytes.Buffer)
	buf := make([]byte, 4) // 使用 4 字节的缓冲区
    // 使用 io.CopyBuffer 函数将数据从 src 复制到 dst
	n, err := io.CopyBuffer(dst, src, buf)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Printf("Copied %d bytes: %s\n", n, dst.String())
}
```

### 读取和写入辅助函数

这些函数用于从 Reader 和 Writer 中读取和写入数据，常用于处理文件、网络数据传输等场景。

- `func ReadFull(r Reader, buf []byte) (n int, err error)`
  - 作用：从 r（io.Reader）读取数据到 buf，直到读取完毕或出现 error。
  - 用途：常用于文件读取、网络数据传输等。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
)

func main() {
	// ReadFull：从 io.Reader 中读取正好指定字节数的数据，如果无法读取足够的字节，会返回ErrUnexpectedEOF错误
	// 创建一个 bytes.Buffer 模拟一个 io.
	r := bytes.NewBuffer([]byte("Hello, World!"))
	// 创建一个字节切片，用于存储读取的数据（缓冲区）
	buf1 := make([]byte, 5)
	// 尝试读取完整的5个字节
	n, err := io.ReadFull(r, buf1)
	if err != nil {
		log.Fatal("Error:", err)
		return
	}
	fmt.Printf("读取了 %d 个字节: %s\n", n, buf1)
	// 尝试读取完整的10个字节，但是剩下8个字节，不满足完整的10字节长度会出现ErrUnexpectedEOF错误
	buf2 := make([]byte, 10)
	n, err = io.ReadFull(r, buf2)
	if err != nil {
		fmt.Println("Error:", err)
		return
	} else {
		fmt.Printf("读取了 %d 个字节: %s\n", n, buf2)
	}
}
```

- `func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)`
  - 作用：从 r（io.Reader）读取数据到 buf，直到读取至少 min 个字节或出现 error。
  - 用途：常用于文件读取、网络数据传输等。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
)

func main() {
	// ReadAtLeast：从 io.Reader 中读取至少指定字节数的数据到缓冲区中。如果读取的字节数少于指定值，会返回错误
	// io.ReadAtLeast 函数提供了一种灵活的方式来读取数据，允许您指定必须读取的最小字节数。
	r := bytes.NewBufferString("Hello, World!")
	buf := make([]byte, 5)
	// 读取至少3个字节
	n, err := io.ReadAtLeast(r, buf, 3)
	if err != nil {
		log.Fatal(err)
		return
	}
	fmt.Printf("读取了 %d 个字节: %s\n", n, string(buf[:n]))
	// 读取剩下的所有字节，因为剩下的字节数小于申请的buf的长度，所以buf会被填满，但是如果，要求的min大于剩下的字节数，就会报错。
	buf2 := make([]byte, 10)
	n, err = io.ReadAtLeast(r, buf2, 8)
	if err != nil {
		log.Println("Error:", err)
	} else {
		fmt.Printf("读取了 %d 个字节: %s\n", n, string(buf2[:n]))
	}
}
```

- `func WriteString(w Writer, s string) (n int, err error)`
  - 作用：将字符串 s 写入 w（io.Writer），直到写入完毕或出现 error。
  - 用途：常用于文件写入、网络数据传输等。
  - 示例：

::: code-group
```go [写入到标准输出]
_, err := io.WriteString(os.Stdout, "Hello, World!\n")
if err != nil {
        fmt.Println("写入错误:", err)
}
```

```go [写入到文件]
file, err := os.Create("output.txt")
if err != nil {
        fmt.Println("创建文件错误:", err)
        return
}
defer file.Close()

_, err = io.WriteString(file, "This is a test string.\n")
if err != nil {
        fmt.Println("写入文件错误:", err)
}
```

```go [写入到内存buffer]
var buffer bytes.Buffer
_, err := io.WriteString(&buffer, "This string is writed to buffer.\n")
if err != nil {
        fmt.Println("写入buffer错误:", err)
}
fmt.Print(buffer.String())
```
:::

### 创建特殊 Reader 和 Writer

这些函数返回实现了 io.Reader 或 io.Writer 接口的对象，用于特定的 I/O 场景。

- `func NopCloser(r Reader) ReadCloser`
  - 作用：将一个 Reader 包装成 ReadCloser，但 Close 方法不执行任何操作。
  - 用途：当需要 ReadCloser 接口但不需要关闭时使用。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
)

func main() {
	// 创建一个 bytes.Buffer，它实现了 io.Reader
	r := bytes.NewBuffer([]byte("Hello, World!"))

	// 使用 io.NopCloser 将其转换为 io.ReadCloser
	rc := io.NopCloser(r)

	// 现在，我们可以将 rc 传递给一个需要 io.ReadCloser 的函数
	buf := make([]byte, 10)
	n, err := rc.Read(buf)
	if err != nil && err != io.EOF {
		fmt.Println("读取错误:", err)
		return
	}
	fmt.Printf("读取了 %d 个字节: %s\n", n, buf[:n])

	// 关闭 rc，但它实际上什么也不做
	err = rc.Close()
	if err != nil {
		fmt.Println("关闭错误:", err)
	}
}
```

- `func LimitReader(r Reader, n int64) Reader`
  - 作用：返回一个新的 Reader，限制从 r 读取的最大字节数为 n。
  - 用途：当需要限制读取数据的大小时使用。
  - 示例：

```go
package main

import (
	"fmt"
	"io"
	"strings"
)

func main() {
	// 创建一个字符串 Reader
	s := strings.NewReader("Hello, Golang!")

	// 创建一个LimitReader限制读取5个字节
	lr := io.LimitReader(s, 5)

	// 读取数据
	buf := make([]byte, 10)
	n, err := lr.Read(buf)

	if err != nil && err != io.EOF {
		fmt.Println("读取错误:", err)
		return
	}

	// 打印读取的字节数和数据
	fmt.Printf("读取了 %d 个字节: %s\n", n, buf[:n])

	//尝试再次读取
	n, err = lr.Read(buf)
	if err == io.EOF {
		fmt.Println("读取完成")
	}
}
```

- `func MultiReader(rs ...Reader) Reader`
  - 作用：将多个 Reader 组合成一个，按顺序读取。返回一个 Reader。
  - 用途：当需要同时读取多个数据源时使用。
  - 示例：

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

func main() {
	// 创建一个 io.Reader 切片，包含两个 Reader：
	// 1. strings.NewReader 从字符串 "Hello, " 创建一个 Reader
	// 2. bytes.NewBufferString 从字符串 "World!!!" 创建一个 BufferReader
	readers := []io.Reader{
		strings.NewReader("Hello, "),
		bytes.NewBufferString("World!!!"),
	}

	// 使用 io.MultiReader 将多个 Reader 组合成一个单一的 Reader
	reader := io.MultiReader(readers...)

	// 创建一个字节切片，用于存储从 Reader 中读取的数据
	data := make([]byte, 0, 128) // 初始长度为 0，容量为 128

	// 创建一个字节切片，用作临时缓冲区
	buf := make([]byte, 10) // 缓冲区大小为 10 字节

	// 循环读取 Reader 中的数据，直到遇到 io.EOF（文件结束）
	for n, err := reader.Read(buf); err != io.EOF; n, err = reader.Read(buf) {
		// 如果读取过程中发生错误，则抛出 panic
		if err != nil {
			panic(err)
		}
		// 将读取到的数据追加到 data 切片中
		data = append(data, buf[:n]...) // buf[:n] 表示实际读取到的数据切片
	}

	// 将 data 切片转换为字符串并打印到控制台
	fmt.Printf("%s\n", data) // 输出：Hello, World!!!
}
```

- `func MultiWriter(ws ...Writer) Writer`
  - 作用：将多个 Writer 组合成一个，按顺序写入。返回一个 Writer。
  - 用途：当需要同时写入多个数据源时使用。
  - 示例：

```go
package main

import (
	"io"
	"os"
)

func main() {
	// 创建一个文件用于写入
	file, err := os.Create("output.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// 创建一个 io.Writer 切片，包含标准输出和文件
	writers := []io.Writer{
		os.Stdout,
		file,
	}

	// 使用 io.MultiWriter 将多个 Writer 组合成一个单一的 Writer
	multiWriter := io.MultiWriter(writers...)

	// 向 multiWriter 写入数据
	data := []byte("Hello, MultiWriter!")
	multiWriter.Write(data)
}
```

::: tip 提示
文档正在更新中...
:::