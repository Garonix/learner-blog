# 错误处理机制

## 什么是错误？

在 Go 语言中，错误（error）是一种内置的类型，用于表示程序中的错误状态。Go 的错误处理方式与其他编程语言有所不同，它采用显式的错误处理机制。

## 异常处理对比

在 `Java` 和 `C#` 等编程语言中，错误处理通常是通过 `try-catch` 机制来管理的。当程序在 `try` 块中遇到错误时，`catch` 块会捕获该错误，并执行相应的处理逻辑。这种机制为处理异常提供了一种结构化的方法，确保即使在发生错误的情况下，应用程序也不会意外崩溃。

与此不同，`Go` 语言采用了一种完全不同的错误处理方式。在 `Go` 中，没有传统意义上的异常处理机制。相反，`Go` 将错误视为函数的返回值之一。这意味着在调用函数后，开发者需要主动检查是否返回了错误，并根据情况决定如何处理它。这种方法更加强调显式的错误处理，而不是像 `try-catch` 那样隐式的异常处理。这不仅使代码逻辑更为清晰，还鼓励了更好的错误管理实践。

## 演示错误

尝试打开一个不存在的文件：

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 使用 os 包的 Open 函数打开文件
	file, err := os.Open("README.md")
	if err != nil {
		fmt.Println(err)
		return
	}
	// 打印文件名称和打印文件打开成功
	fmt.Println(file.Name(), "open file success.")
}
```

在 `os` 包中有打开文件的功能函数：func Open(name string) (*File, error) 如果文件已经成功打开，那么 Open 函数将返回文件处理。如果在打开文件时出现错误，将返回一个非 nil 错误。

如果一个函数或方法返回一个错误，那么按照惯例，它必须是函数返回的最后一个值。因此，Open 函数返回的值是最后一个值。

处理错误的惯用方法是将返回的错误与nil进行比较。nil 值表示没有发生错误，而非 nil 值表示出现错误。在我们的例子中，我们检查错误是否为 nil。如果它不是 nil，我们只需打印错误并从主函数返回。

运行结果：

```txt
open README.md: no such file or directory
```

程序输出结果是得到了一个错误，说明该文件不存在。

## error类型

在 Go语言标准库的内置包 `builtin` 的 `error` 接口来表示错误，源码如下：

```go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
```

任何实现了 `Error() string` 方法的类型都满足这个接口。

既然我们支持错误是一种接口，可以在源码中了解更多关于错误的信息。

在上述演示错误案例中，我们仅仅是打印了错误的描述。如果我们想要的是导致错误的文件的实际路径。一种可能的方法是解析错误字符串。这是我们程序的输出：

```txt
open README.md: no such file or directory
```

我们可以解析这个错误消息并从中获取文件路径 "README.md"。但这是一个糟糕的方法。在新版本的语言中，错误描述可能随时更改，我们的代码将会中断。

是否有办法可靠地获取文件名？答案是肯定的，它可以做到，Go 标准库使用不同的方式提供更多关于错误的信息。

**断言底层结构类型并从结构字段获取更多信息**

如果仔细阅读 `Open()` 函数的文档，可以看到它返回的是 `PathError` 类型的错误。

![image-16](/images/docs/Go语言/Go语言基础/assets/image-16.png)

`PathError` 是一个结构体，标准库的实现代码如下：

```go
// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }
```

从上面的代码中，我可以理解 `PathError` 通过声明 `Error() string` 方法实现了错误接口。该方法连接操作、路径和实际错误并返回它。这样我们就得到了错误信息：

```txt
open README.md: no such file or directory
```

`PathError` 结构体的路径字段包含导致错误的文件的路径。让我们修改上面写的程序，并打印出路径，修改后的代码如下：

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 使用 os 包的 Open 函数打开文件
	file, err := os.Open("README.md")
	if err, ok := err.(*os.PathError); ok {
		fmt.Println("File at path", err.Path, "failed to open")
		return
	}
	// 打印文件名称和打印文件打开成功
	fmt.Println(file.Name(), "open file success.")
}
```

在上面的程序中，我们使用类型断言获得错误接口的基本值。然后自定义错误输出：

```txt
File at path README.md failed to open
```

**断言底层数据结构并使用方法获取更多信息**

获得更多信息的第二种方法是断言底层类型，并通过调用 `struct` 类型的方法获取更多信息。

如下 DNSError：

```go
// DNSError represents a DNS lookup error.
type DNSError struct {
	// ...
}

// Unwrap
func (e *DNSError) Unwrap() error {
	// ...
}

// Error
func (e *DNSError) Error() string {
	// ...
}

// Timeout
func (e *DNSError) Timeout() bool {
	// ...
}

// Temporary
func (e *DNSError) Temporary() bool {
	// ...
}
```

从上面的代码中可以看到，DNSErrorstruct 有三个方法，`Timeout() bool` 和 `Temporary() bool` 它们返回一个布尔值，表示错误是由于超时还是临时的，`Unwrap() error` 返回一个 error 类型的值，这个方法用于返回嵌套的错误。如果 DNSError 中包含另一个错误（例如，底层 DNS 查找引发的错误），这个方法将返回那个错误。这个方法的主要目的是实现 Go 1.13 引入的错误处理机制，允许错误链的提取。

让我们编写一个断言 DNSError 类型的程序，并调用这些方法来确定错误是临时的还是超时的。

代码如下：

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	addr, err := net.LookupHost("google.com.cn")
	// 断言错误类型
	if err, ok := err.(*net.DNSError); ok {
		if err.Timeout() {
			fmt.Println("operation timed out")
		} else if err.Temporary() {
			fmt.Println("temporary error")
		} else {
			fmt.Println("generic error: ", err)
		}
		return
	}
	fmt.Println(addr)
}
```

在上面的程序中，我们正在尝试获取一个无效域名的 IP 地址，这是一个无效的域名：google.com.cn

在我们的例子中，错误既不是暂时的，也不是由于超时，因此程序会打印出来：

```txt
generic error:  lookup google.com.cn: no such host
```

## 创建error

创建一个error有以下两种方式，第一种是使用 `errors` 包下的 `New()` 函数，第二种是使用 `fmt` 包下的 `Errorf()` 函数，可以得到一个格式化参数的error。

下面是完整的示例：

::: code-group
```go [New()]
package main

import (
	"errors"
	"fmt"
)

func main() {
	// 第一种方式创建 error 通过 errors 包的 New() 函数
	// res1, err := sum1(10, 20)
	res1, err := sum1(-10, -20)
	if err != nil {
		panic(err)
	}
	fmt.Println(res1)
}

// sum1
func sum1(a, b int) (int, error) {
	if a < 0 && b < 0 {
		return 0, errors.New("参数必须大于0")
	}
	return a + b, nil
}
```

```go [Errorf()]
package main

import "fmt"

func main() {
	// 第二种方式创建 error 通过 fmt 包的 Errorf() 函数
	// res2, err := sum2(11, 22)
	res2, err := sum2(-11, -22)
	if err != nil {
		panic(err)
	}
	fmt.Println(res2)
}

// sum2
func sum2(a, b int) (int, error) {
	if a < 0 && b < 0 {
		return 0, fmt.Errorf("参数必须大于0")
	}
	return a + b, nil
}
```
:::

大部分情况，为了更好的维护性，一般都不会临时创建error，而是会将常用的error当作全局变量使用，例如下方节选自 `os\erros.go` 文件的代码。

```go
// Portable analogs of some common system call errors.
//
// Errors returned from this package may be tested against these errors
// with [errors.Is].
var (
	// ErrInvalid indicates an invalid argument.
	// Methods on File will return this error when the receiver is nil.
	ErrInvalid = fs.ErrInvalid // "invalid argument"

	ErrPermission = fs.ErrPermission // "permission denied"
	ErrExist      = fs.ErrExist      // "file already exists"
	ErrNotExist   = fs.ErrNotExist   // "file does not exist"
	ErrClosed     = fs.ErrClosed     // "file already closed"

	ErrNoDeadline       = errNoDeadline()       // "file type does not support deadline"
	ErrDeadlineExceeded = errDeadlineExceeded() // "i/o timeout"
)
```

## 自定义error

在 Go 语言中，可以通过实现 `error` 接口中的 `Error()` 方法来自定义错误。例如 `erros` 包下的 `errorString` 就是一个很简单的实现。

```go
func New(text string) error {
   return &errorString{text}
}

// errorString结构体
type errorString struct {
   s string
}

func (e *errorString) Error() string {
   return e.s
}
```

```go
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("Code: %d, Message: %s", e.Code, e.Message)
}

func NewMyError(code int, message string) error {
    return &MyError{
        Code:    code,
        Message: message,
    }
}
```

## 错误传递

## 错误链

## panic

## recover

## 参考资料

- [https://shgopher.github.io/GOFamily/基础/错误处理/](https://shgopher.github.io/GOFamily/基础/错误处理/)
- [https://hedon954.github.io/noteSite/backend/golang/02_grammar/error.html](https://hedon954.github.io/noteSite/backend/golang/02_grammar/error.html)
- [https://golang.xiniushu.com/语言入门/语法进阶/95.error.html](https://golang.xiniushu.com/语言入门/语法进阶/95.error.html)