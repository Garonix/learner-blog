# 结构体和方法

## 结构体

### 什么是结构体？

在 Go 语言中，结构体（struct）是一种用户定义的数据类型，用于组合不同类型的数据项。结构体可以包含零个或多个字段（fields），每个字段都有自己的类型和名称。

### 结构体的定义

结构体的定义使用 type 关键字和 struct 关键字，通常形式如下：

```go
type StructName struct {
    Field1 type1
    Field2 type2
    // ...
}
```

下面是定义结构体的示例：

```go
// 定义一个用户结构体
type User struct {
	Name    string
	Age     int
	Sex     string
	address string
}
```

示例结构体说明：
- 结构体名称为 `User` 首字母大写，根据我们所学的首字母大写可导出的知识，它是包级可导出结构。
- 结构体中的字段 `Name`、`Age`、`Sex` 首字母大写，所以它是可导出字段，`address` 是小写，所以他们俩不可导出。

### 初始化

1. **使用字段名的方式初始化**：这种方式要求按照结构体定义的字段顺序依次赋值。

```go
// 定义结构体
type Person struct {
    Name string
    Age  int
    City string
}

// 初始化结构体并赋值
var p1 Person
p1.Name = "Alice"
p1.Age = 30
p1.City = "New York"
```

2. **使用键值对方式初始化**：可以指定字段名和对应的值进行初始化，顺序可以任意。

```go
// 初始化结构体并赋值
p2 := Person{
    Name: "Bob",
    City: "San Francisco",
    Age:  25,
}
```

3. **使用 new 函数初始化**：使用 new 函数创建结构体的指针，并返回指向新分配的零值结构体的指针。

```go
// 使用 new 函数初始化结构体指针
p3 := new(Person)
p3.Name = "Charlie"
p3.Age = 35
p3.City = "Chicago"
```

4. **匿名结构体初始化**：直接在初始化时定义结构体类型和字段，不需要提前定义结构体类型。

```go
// 初始化匿名结构体并赋值
p4 := struct {
    Name string
    Age  int
}{
    Name: "David",
    Age:  28,
}
```

### 结构体的访问

可以通过 `.` 的方式来访问结构体中的字段。

示例：

```go
package main

import "fmt"

func main() {
	// 初始化结构体
	u1 := User{
		name:    "MagicGopher",
		age:     20,
		sex:     "男",
		address: "地球",
	}
	// 通过 . 的方式获取结构体的字段的值
	fmt.Printf("name:%v\n", u1.name)
	fmt.Printf("age:%v\n", u1.age)
	fmt.Printf("sex:%v\n", u1.sex)
	fmt.Printf("address:%v\n", u1.address)
}

// 定义一个结构体
type User struct {
	name    string
	age     int
	sex     string
	address string
}
```

还可以通过指针来访问结构体的字段，下面是一个示例，展示如何使用指针来访问结构体的字段：

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    // 创建一个 Person 类型的指针
    p := &Person{
        Name: "Bob",
        Age:  25,
    }

    // 通过指针访问结构体字段
    fmt.Println("Name:", p.Name)
    fmt.Println("Age:", p.Age)

    // 修改结构体字段
    p.Age = 26
    fmt.Println("Modified Age:", p.Age)
}
```

### 结构体是值类型

在 Go 语言中，结构体是值类型。这意味着当你将一个结构体赋值给另一个结构体变量时，实际上是复制了整个结构体的内容，而不是引用同一个内存地址。

示例：

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    p1 := Person{Name: "Alice", Age: 30}
    p2 := p1 // 这里是值拷贝

    p2.Name = "Bob" // 修改 p2 不会影响 p1

    fmt.Println(p1.Name) // 输出: Alice
    fmt.Println(p2.Name) // 输出: Bob
}
```

在这个例子中，p1 和 p2 是两个独立的结构体变量，修改 p2 不会影响 p1。

如果你希望在多个地方共享同一个结构体的引用，可以使用指针。例如：

```go
func main() {
    p1 := &Person{Name: "Alice", Age: 30} // p1 是指向结构体的指针
    p2 := p1 // 这里是指针拷贝

    p2.Name = "Bob" // 修改 p2 会影响 p1

    fmt.Println(p1.Name) // 输出: Bob
    fmt.Println(p2.Name) // 输出: Bob
}
```

### 结构体嵌套

结构体嵌套是指在一个结构体中定义另一个结构体作为字段。这种方式可以用来建立更复杂的数据结构。

示例：

```go
type Address struct {
    City  string
    State string
}

type Person struct {
    Name    string
    Address Address // 嵌套结构体
}
```

### 结构体匿名字段

在 Go 语言中，结构体的匿名字段（也称为嵌入字段）是指在结构体中声明的没有命名的字段。这种特性允许我们通过嵌入其他结构体来实现组合，从而重用字段和方法。

示例：

```go
package main

import (
    "fmt"
)

// 定义一个嵌入的结构体
type Address struct {
    City  string
    State string
}

// 定义一个包含匿名字段的结构体
type Person struct {
    Name    string
    Address // 匿名字段
}

func main() {
    p := Person{
        Name: "Alice",
        Address: Address{
            City:  "Wonderland",
            State: "Fantasy",
        },
    }

    fmt.Println("Name:", p.Name)
    fmt.Println("City:", p.City) // 直接访问匿名字段的字段
    fmt.Println("State:", p.State)
}
```

结构体匿名字段的特点：
- 字段访问：可以直接访问匿名字段的字段，而无需通过字段名称进行间接访问。
- 方法继承：如果匿名字段是一个结构体类型，它的方法也会被继承，这样可以方便地调用。
- 灵活性：通过匿名字段，可以很容易地组合多个结构体，使得代码更加模块化和可读。

使用场景：
- 适用于需要组合多个对象的场景。
- 尤其在实现接口或重用代码时非常有用。

### 导出结构体和字段

在 Go 语言中，根据首字母大小写访问的原则，导出结构体和字段的规则是基于标识符的首字母大小写。例如：结构体、字段、方法或接口的名称以大写字母开头，那么它是导出的，可以被包外的代码访问，如果名称以小写字母开头，则该结构体、字段、方法或接口是未导出的，只能在定义它的包内访问。

示例：

```go
package main

import "fmt"

// 导出结构体
type Person struct {
    Name string // 导出的字段
    age  int    // 未导出的字段
}

// 导出方法
func (p Person) GetName() string {
    return p.Name
}

// 未导出方法
func (p Person) getAge() int {
    return p.age
}

func main() {
    p := Person{Name: "Alice", age: 30}
    fmt.Println("Name:", p.GetName()) // 可以访问
    // fmt.Println("Age:", p.getAge()) // 不能访问，会报错
}
```

::: warning 导出结构体和字段注意事项
- 导出字段和方法可以被其他包的代码访问，而未导出字段和方法只能在同一包内访问。
- 在使用结构体时，通常只暴露必要的字段和方法，以保持封装性。

**导出结构体和字段总结**
- 导出：首字母大写
- 未导出：首字母小写
:::

### 结构体比较

在 Go 语言中，结构体的比较可以通过内置的比较运算符（如 `==` 和 `!=`）来实现，但有一些注意事项和限制。

结构体比较的基本原则：
- 相同数据类型：只有同类型的结构体可以直接比较。
- 所有字段可比较：结构体的所有字段都必须是可比较的类型（即支持比较运算符）。例如，基本类型（如 int、string、float）和某些其他类型（如数组）是可比较的，而包含切片、映射和函数等不可比较类型的结构体则不能进行比较。

示例：

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p1 := Person{Name: "Alice", Age: 30}
    p2 := Person{Name: "Alice", Age: 30}
    p3 := Person{Name: "Bob", Age: 25}

    fmt.Println(p1 == p2) // true，内容相等
    fmt.Println(p1 == p3) // false，内容不相等
}
```

不可比较类型：如果结构体包含切片、映射或函数字段，则无法直接使用 == 进行比较。例如：

```go
type Example struct {
    Data []int // 切片不可比较
}

func main() {
    e1 := Example{Data: []int{1, 2, 3}}
    e2 := Example{Data: []int{1, 2, 3}}
    
    // fmt.Println(e1 == e2) // 这会导致编译错误
}
```

对于包含不可比较字段的结构体，可以通过自定义方法实现比较逻辑。例如：

```go
type Example struct {
    Data []int
}

func (e Example) Equal(other Example) bool {
    if len(e.Data) != len(other.Data) {
        return false
    }
    for i := range e.Data {
        if e.Data[i] != other.Data[i] {
            return false
        }
    }
    return true
}

func main() {
    e1 := Example{Data: []int{1, 2, 3}}
    e2 := Example{Data: []int{1, 2, 3}}

    fmt.Println(e1.Equal(e2)) // true
}
```

::: info 总结
- 结构体可以使用 == 和 != 进行比较，但所有字段必须是可比较的类型。
- 如果结构体包含不可比较类型的字段，可以定义自定义比较方法。
:::

### 结构体作为函数的参数

在 Go 语言中，结构体（struct）是一种用户定义的数据类型，可以用来组合多个相关的字段。结构体可以作为函数的参数传递，这个特性非常强大，可以帮助我们组织和管理代码。

首先，我们需要定义一个结构体。例如，定义一个表示 Person 的结构体，如下：

```go
type Person struct {
    Name string
    Age  int
}
```

有两种方式将结构体作为函数参数传递：值传递和引用传递。

在值传递中，函数接收的是结构体的一个副本。修改副本不会影响原始结构体。

```go
func UpdatePerson(p Person) {
    p.Age += 1 // 只会修改副本
}

func main() {
    person := Person{Name: "Alice", Age: 30}
    UpdatePerson(person)
    fmt.Println(person.Age) // 输出: 30
}
```

在引用传递中，函数接收的是结构体的指针。修改指针指向的内容会影响原始结构体。

```go
func UpdatePerson(p *Person) {
    p.Age += 1 // 修改原始结构体
}

func main() {
    person := Person{Name: "Alice", Age: 30}
    UpdatePerson(&person) // 传递指针
    fmt.Println(person.Age) // 输出: 31
}
```

使用结构体作为函数的参数，选择传递方式：
- 值传递适用于结构体较小（例如只有几个字段），因为它会创建一个副本。如果结构体较大，使用值传递会消耗更多的内存和时间。
- 引用传递适用于结构体较大，或者当你希望在函数内修改原始结构体时。

以下是一个完整的示例，展示了如何使用结构体作为函数参数：

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func UpdateAge(p *Person) {
    p.Age += 1 // 修改原始结构体
}

func main() {
    person := Person{Name: "Alice", Age: 30}
    fmt.Println("Before update:", person.Age) // 输出: 30

    UpdateAge(&person) // 传递指针
    fmt.Println("After update:", person.Age) // 输出: 31
}
```

::: warning 注意事项
- 使用指针传递时，要确保指针不为 nil，否则可能导致运行时错误。
- 当结构体中包含指针或引用类型字段时，请注意可能的共享状态和并发访问问题。
:::